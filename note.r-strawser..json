/* futurenft.near
https://github.com/r-strawser/subgraph-refinery
--> */

//main, we are familiar with the readme and the process

//but we need to know the followings...



//utils...
//https://github.com/r-strawser/subgraph-refinery/tree/main/utils
//


//https://stackoverflow.com/questions/48857545/how-can-i-avoid-no-test-specified-errors-in-npm
//makging sense of package.json in https://github.com/r-strawser/subgraph-refinery/blob/main/utils/package.json
// "scripts": {
//  "test": "echo \"Error: no test specified\" && exit 1"
//},
//need to specify under teset something like...
//"mocha --ui tdd tests/callbacks.js", // or "scripts":{ "test":"mocha" }//or "jest"
//probably depends on the file..

//basically a bunch of stuff here to query stuff from near...
//ok this is really cool...
//we should try and test some of this out..

//view contract method, view nft metdata, view nft token, view tx details in range.js....
//test some of these files
//LAST


//how do these template files then relate to what is in the following..
//tenk-dao --> contract methods, get-policy, get-tx-results, tx-details...
//

//dope shit....https://docs.npmjs.com/creating-a-package-json-file

//looks like we want to use node to run those scripts...


//pretty cool stuff in here... looks like we can mess around with the utils...
//querying stuff from the end points...
//"node ./scripts/TEMPLATES/view-contract-methods.js"
//using futurenft.near...

/* 
{
  methodNames: [
    'claim',
    'create_account_and_claim',
    'get_key_balance',
    'check_key',
    'on_create_and_claim',
    'get_linkdrop_contract',
    'nft_payout',
    'nft_transfer_payout',
    'new_default_meta',
    'new',
    'add_whitelist_accounts',
    'whitelisted',
    'close_contract',
    'start_presale',
    'start_sale',
    'nft_mint',
    'nft_burn',
    'create_linkdrop',
    'nft_mint_one',
    'nft_mint_many',
    'cost_of_linkdrop',
    'total_cost',
    'cost_per_token',
    'token_storage_cost',
    'tokens_left',
    'nft_metadata',
    'remaining_allowance',
    'transfer_ownership',
    'update_royalties',
    'update_allowance',
    'update_uri',
    'get_sale_info',
    'get_user_sale_info',
    'mint_special',
    'initial',
    'on_send_with_callback',
    'link_callback',
    'nft_transfer',
    'nft_transfer_call',
    'nft_token',
    'nft_resolve_transfer',
    'nft_approve',
    'nft_revoke',
    'nft_revoke_all',
    'nft_is_approved',
    'nft_total_supply',
    'nft_tokens',
    'nft_supply_for_owner',
    'nft_tokens_for_owner'
  ],
  probableInterfaces: [ 'nep171', 'nep177', 'nep178' ],
  byMethod: {
    claim: [],
    create_account_and_claim: [],
    get_key_balance: [],
    check_key: [],
    on_create_and_claim: [],
    get_linkdrop_contract: [],
    nft_payout: [],
    nft_transfer_payout: [],
    new_default_meta: [],
    new: [],
    add_whitelist_accounts: [],
    whitelisted: [],
    close_contract: [],
    start_presale: [],
    start_sale: [],
    nft_mint: [],
    nft_burn: [],
    create_linkdrop: [],
    nft_mint_one: [],
    nft_mint_many: [],
    cost_of_linkdrop: [],
    total_cost: [],
    cost_per_token: [],
    token_storage_cost: [],
    tokens_left: [],
    nft_metadata: [ 'nep177' ],
    remaining_allowance: [],
    transfer_ownership: [],
    update_royalties: [],
    update_allowance: [],
    update_uri: [],
    get_sale_info: [],
    get_user_sale_info: [],
    mint_special: [],
    initial: [],
    on_send_with_callback: [],
    link_callback: [],
    nft_transfer: [ 'nep171' ],
    nft_transfer_call: [ 'nep171' ],
    nft_token: [ 'nep171' ],
    nft_resolve_transfer: [],
    nft_approve: [ 'nep178' ],
    nft_revoke: [ 'nep178' ],
    nft_revoke_all: [ 'nep178' ],
    nft_is_approved: [ 'nep178' ],
    nft_total_supply: [],
    nft_tokens: [],
    nft_supply_for_owner: [],
    nft_tokens_for_owner: []
  }
} */

//was able to pul token and nft meta details...

//trying to pull trx details...
//having trouble setting the account stuff...
//account id --> ok we got the account stuff set up, try pulling trx details...


//LAST...

//after this, take a look at the graphQL...
//from s-strawser...
//what else can we do with this?
//how do our overall queries look?
//is there anything we need to add --> nft_mint_many for example?
  //are our data pulls ok?

//any response form s-strawser yet on this stuff? added use to discord yet?
//

//after this, get a json file to query from an api and modify it to query from graph?  
//or do we do this with apollo?
//



//understanding the schema they are putting together...

type _Schema_
  @fulltext(
    name: "nftSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Token", fields: [{ name: "ownerId" }, { name: "mintedBy" }, { name: "tokenId" }] }]
  )

//how does this work?
features:
  - ipfsOnEthereumContracts
  - fullTextSearch
//need these featurs in the subgraph.yml
//currently this version of our search/query has no features...

//ok, back to what a schema is...
//https://thegraph.com/docs/en/developer/create-subgraph-hosted/#the-graphql-schema
//Defining Fulltext Search Fields#
type _Schema_
  @fulltext(
    name: "bandSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Band", fields: [{ name: "name" }, { name: "description" }, { name: "bio" }] }]
  )
  //what does the algorithm 'rank' do? ---> do a search to find out more information on this..
  //probably doesn't matter, but worth checking out...


type Band @entity {
  id: ID!
  name: String!
  description: String!
  bio: String
  wallet: Address
  labels: [Label!]!
  discography: [Album!]!
  members: [Musician!]!
}

//will produce a query like...

query {
  bandSearch(text: "breaks & electro & detroit") {
    id
    name
    description
    wallet
  }
}

//-->so in the hosted service deployed, we can search for e.g. 


//critical answer to question from yesterday!
//https://thegraph.com/docs/en/developer/graphql-api/#queries
//so basically, if you we find our token and our owner and update through all the blocks, we will get the most recent owner of it...
//ok, this is amazing!
//You can query the state of your entities not just for the latest block, which is the by default, but also for an arbitrary block in the past. The block at which a query should happen can be specified either by its block number or its block hash by including a block argument in the toplevel fields of queries.
//default behavior of query for entity --> is the latest block
//some query functionality we might want to explore...

//it is possible to query from a specific block...
//full text search description is also here
//question about full text search --> e.g. does the search "breaks & electro & detroit" --> look for the occurence of this text
//in any of the fields ? --> or is like first field contains break, second field contains electro, and third field contains detroit?
//ASK THIS IN DISCORD... not critical at the moment...
//I think what it must to is that it checks across the 3 fields provided here :include: [{ entity: "Band", fields: [{ name: "name" }, { name: "description" }, { name: "bio" }] }]
//in order to try and meet the conditionn bandSearch(text: "breaks & electro & detroit")

//how does Strawser end up using his filter?
//it seems like this might point to how strawser's approach to querying is different from the one we have in this repo...
//Ok, so this is a question we could ask strawzer...


//#0 Question FOR STRAWER... -method: txs.actions[0].FunctionCall.method_name,
//is failing in view-tx-details-in-range.js --> any idea why this could be?  were you able to run it?
  //I haven't dug into yet cause I don't think it is critical to what I am doing, but just interested...
  //check our otherscripts, we might want to include a null check?
  //is actions[0]
  //low priority...
  //but this might be able to help...
  //https://thegraph.com/docs/en/developer/assemblyscript-api/
//# 1 QUESTION FOR STRAWSER...  - more of a confirmation .. - from template collection
type _Schema_
@fulltext(
name: "nftSearch"
language: en
algorithm: rank
include: [{ entity: "Token", fields: [{ name: "ownerId" }, { name: "mintedBy" }, { name: "tokenId" }, { name: "prev_ownerId" }] }]
)
//if in my query I write for example...
//it will check to fulfill the condition "ownernft.near & minternft.near & 1111 & prevownernft.near" when looking
//at all of the defined fields above simultaneously...
//so that if in this case ownerId = ownernft.near, mintedBy = minternft.near, tokenId = 1111, and prev_ownerId = prevownernft.near
//but a query with e.g. only "text="ownernft.near"" would also be satisfied by the same record that was returned in the previous query?
//just like a query with e.g. only "text="prevownernft.near"" would also be satisfied by the same record etc...

query {
  bandSearch(text: "ownernft.near & minternft.near & 1111 & prevownernft.near") {
    id
    signerId
    tokens
    sent
    received
    royalties
    total_owned
    total_transferred
    last_updated
  }
}


//it is a really good idea to have these full text searches in place to verify the quality of our results, so we should ask him about...

//ok, given what we know now about the part above, then, what can we then use the debug-collection-meta for to help us with?
//basically, it allows us to search for all of the method names that were used for example...
//but come back to thise
COME BACK ^^^


//next thing to look at in extinctheroes collection schema.graphql...
//how to make use of 'derived from'
//basically there are other entities like, 'Token' that have the fields ID and also the fields
//ok pretty sure what this does is it pulls int he field 
  //e.g. owner and then with that entry for the owner it lists all of the Token entities that go with it..
  //I believe this is indeed what we got when we ran dabits query 
  //yes, it is , you can see the schema.graphql
  //as well as the result posted below this snipet from strawser..


type Account @entity {
  id: ID!
  signerId: String!
  tokens: [Token!]! @derivedFrom(field: "owner")
  sent: [Transfer!]! @derivedFrom(field: "from")
  received: [Transfer!]! @derivedFrom(field: "to")
  royalties: [Royalty!]! @derivedFrom(field: "addresses")
  total_owned: BigInt!
  total_transferred: BigInt!
  last_updated: String!
  total_royalties_received: BigInt!
}



//keeping track of price behavior...
//we can see blockIDs, price sold, rarities etc...
//so this would be good for tracking price behavior etc...
//sent message to KT to see if anyone is interested in this sort of stuff...
//Also, sent a message to lex on this...

type Token @entity {
  id: ID!
  standard: String!
  version: String!
  event: String!
  owner: Account!
  ownerId: String
  prev_ownerId: String
  tokenId: String
  metadata: String
  image: String

  total_transfers: BigInt!
  transfers: [Transfer!]! @derivedFrom(field: "nft")
  mints: [Mint!]! @derivedFrom(field: "nft")
  sales: [Royalty!]! @derivedFrom(field: "nft")

  mintedBy: String!
  original_minter: Contract!
  minted_timestamp: String!
  minted_blockHeight: String!

  total_mints: BigInt!
  prev_sale_price: BigInt

  contract: Contract!
}

//https://thegraph.com/docs/en/developer/create-subgraph-hosted/#the-graphql-schema
//the above is called a reverse look up...
type Token @entity {
  id: ID!
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "token")
}

type TokenBalance @entity {
  id: ID!
  amount: Int!
  token: Token!
}


//a better example from darbit...
//schema.graphql
type Token @entity {
  id: ID!
  owner: User!
  ownerId: String!
  tokenId: String!
}

type User @entity {
  id: ID!
  tokens: [Token!]! @derivedFrom(field: "owner")
}

//query...
{
  tokens(first: 5) {
    id
    owner {
      id
    }
    ownerId
    tokenId
  }
  users(first: 5) {
    id
    tokens {
      id
    }
  }
}

//users section of result...
"users": [
  {
    "id": "00bf0b6eac8345f3d8b7f1f5e0c6967bbc4d7762f64e33f5dd4e7f6dadc7a916",
    "tokens": [
      {
        "id": "1026"
      },
      {
        "id": "1851"
      },
      {
        "id": "2099"


//Ok, so given this... what is the best way for us to query our data...

//all we want to have is the users who currently hold NFTs...
//


//then, take a look at the mapping file in extinct heroes collection...


//then, take a look at the mapping file in template or debug (choose the one that looks more interesting...)



//some later ideas --> we could get some really cool meta data on e.g. daos --> e.g. pulling policy updates and things like that...
//something to mention to Jordan...
//

//update our query to do the following: 
//(functionCall.methodName == 'nft_mint_one' || functionCall.methodName == 'nft_mint_many' || functionCall.methodName == 'link_callback' || functionCall.methodName == 'nft_mint')
//we identified some methdods which we might miss..
//we do not know what the event json is like for these....
//we can probably use some of the template queries to grab all the events across all the interaction types...
// but lets wait on jordan to get back to us on this...
// but we could be able to get the details of these...


//1 option look at debug/schema.. there is a functino log here...
//I think we want to create an entity like transfer in 
//and include the method name?
//or something like functioncalllog
//.. but with the whole json returned from the event...
//.. would that help?



//DO THIS NEXT...
//Ok, so all we need to do is deploy this graph...
//
//we can actually use debug directly...
//ok... let's try that...
//how would we use it...?
//do a function search... search..
//for all the candidate methods we think are involved...
//search for the ones we think are involved...

//then do a transfer search...
//







