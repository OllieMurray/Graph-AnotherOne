/* futurenft.near
nft_transfer_payout.method.json
-->slightly different than the reference example - square brackets are in here... --> not sure if that matters much...
-->could just be data here is an array, wheres in https://vitalpoint.ai/course/subgraph-schema/ it is not
-->but we should be able to work this out...
https://explorer.near.org/accounts/futurenft.near
https://explorer.near.org/transactions/88snYzWTrHoQqU5s83LL3duXPXbYEr5LUAqe727cyoPg
https://nomicon.io/Standards/NonFungibleToken/Event
https://nomicon.io/Standards/NonFungibleToken/Core#nft-interface
--> */

EVENT_JSON:{"standard":"nep171",
    "version":"1.0.0",
    "event":"nft_transfer",
    "data":[{
        "old_owner_id":"paranftvi.near",
        "new_owner_id":"nathann.near",
        "token_ids":["2128"]
        }]
    }

/*mistfits.tenk.near
buy in contract...
-->what does the event json look like...
https://explorer.near.org/accounts/misfits.tenk.near
https://explorer.near.org/transactions/DQtFZKcV3PtPpPm6WfDY3YC4vYusQ4QCveFnsF3grjdE
*/
//given the similarities, we may be able to leverage the work done here...
//
//only difference here is that there is an authorized ID in the data...
//-->ok, so let's take a look at the mapping.ts file to see if we can 
//match it up with the event.json here...
//for future reference --> can we look at NEP 171 and see the log...
//just look at the event signatures from here...
//ok, this is the quickest way to do this...
//

EVENT_JSON:{"standard":"nep171",
    "version":"1.0.0",
    "event":"nft_transfer",
    "data":[{"authorized_id":"marketplace.paras.near",
        "old_owner_id":"mildmild.near",
        "new_owner_id":"ajcnyc.near",
        "token_ids":["731"]
        }]
    }

//probably want to account for the possibility of batch purchases?
//



//ok, now we want to find the mint function as well...
//can we also search for when the first block was? --> this is a good idea, we need to include that in of thegraph files...
//need to figure out the start block --> how can we map 
//eg. here https://explorer.near.org/accounts/misfits.tenk.near 
//there is a created by transaction --> https://explorer.near.org/transactions/6zCsbG2twP24q9JKCGy2amSnu7WWoNt1AtMSh7izHam2
//in there, there is a blockhash --> https://explorer.near.org/blocks/FwgZ85iavmKRNnFBnPHKAT3XZSaZ1xs8jAs1sZqptxgH
//in the blockhash --> there is a block# --> in this case 53472067 --> this matches up with what was in the other guys code...
//so we found the correct starting blockhash...
//


//futurenft.near was created on:
//https://explorer.near.org/transactions/DtywfsfoLgJ4qs4Bi7HCXxYPKYLzensKHLWCJkmAPMTV
//the blockhash is: https://explorer.near.org/blocks/85Apqn3PWg4FruqKwWsSnvm7SMU7igFRzVwJy1ar2vXN
//the block id is --> 56977958!
//so change the subgraph.yaml to reflect this...
//


//ok, we still need to find a call to the mint function...
//more l
//https://nomicon.io/Standards/NonFungibleToken/Event
//single owner batch minting...

EVENT_JSON:{
    "standard": "nep171",
    "version": "1.0.0",
    "event": "nft_mint",
    "data": [
      {"owner_id": "foundation.near", "token_ids": ["aurora", "proximitylabs"]}
    ]
  }

//multiple owner batch minting...
EVENT_JSON:{
    "standard": "nep171",
    "version": "1.0.0",
    "event": "nft_mint",
    "data": [
      {"owner_id": "foundation.near", "token_ids": ["aurora", "proximitylabs"]},
      {"owner_id": "user1.near", "token_ids": ["meme"]}
    ]
  }

//challenge, these NFT events above are not specified in the core standard...
//the only one that is is the nft_transfer...

//for example in https://github.com/dabit3/near-subgraph-workshop
//there is an nft_mint_one method that is called, not nft_mint...
//so if we are looking for mints... we probably want to check out for ...
//like contains 'mint' --> 

//other option could be to scrolll all the way down the etherscan... to see what the first calls were...
//needs to be a better way to do this...
//this is a serious challenge though...

//if the mint event also triggers a transfer event, then we can only focus on transfer events...
//that would be good...



  //one thing we might also want to consider...
  //the burn logs...
  //i.e. accounting for burned NFTs...
  //i.e. any NFTs which have been burned should not have their owners counted...


  //is there anyway to expose the interface and all the public methods of a contract?
  //is this possible in near, nothing in the CLI seems to indicate this is possible...
  //for now, just assume the call is like 'mint' and is roughly similar to the event log for mint we have above...
  //


  //to test our query, find the last purchase on the nearscan, take the blockheigth and use that...
  //make sure we pull the right value...
  //then work down the block heights, get more results...
  //and select for only the most recent one for each token  id...
  //basically we need to do a group by, and order by the most recent...
    //is there a blockid or some sort of time stamp we can also pull?
    //that would be very helpful..
    //


//ok, repo from tenk --> this should help...
//https://github.com/TENK-DAO/tenk
//looks like the methods are nft_mint_one
//and nft_mint_many...
//not sure what the logs look liek though yet...

//check out utils.rs///
//log_mint --> looks like the log is events::NFTMint --> 
//use near_contract_standards::non_fungible_token::{Token, events::NftMint};
//so it probably just uses the event as it is defined in the token standard...
//ok, cool, we're good!

//next steps...
//check the mappings against the event structure for mint...
//just assume it is the same for the reference repo we found...

//does this make sense?  is the reference repo pulling data correctly?
//first version of query, did not have 


//if we still don't get all, then drop the ipfs part from the mapping..
//but it probaly shouldn't matter...
//https://explorer.near.org/accounts/andedyuhina.near
//this account came up, we see they called nft_mint_one...
//did not buy... 
//https://explorer.near.org/accounts/0hmyxiaoryls.near...
//this guys called both nft_transfer and nft_mint_one
//transfer: https://explorer.near.org/transactions/npV7FcyfFLobTcJmXoTbTRj9L4rmMM5okduVCnCAjnQ
//EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"old_owner_id":"0hmyxiaoryls.near","new_owner_id":"thisjoys.near","token_ids":["1025"]}]}
//https://explorer.near.org/transactions/DX7TDq28F9JFaYmDLX6YaZjuzEtdDaSVsjNN4gFAHfSN
//mint_one:EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"0hmyxiaoryls.near","token_ids":["1025"]}]}
//1025 was transferred --> did we pick this up?
//https://explorer.near.org/transactions/6tFCo9vpKHTekkmDWU9jW5BydFJukpKFVvaFyzA18cEy
//mint_one: EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"0hmyxiaoryls.near","token_ids":["2334"]}]}
//do we get 2334? --> this is not being picked up, but it should based on it being there due to mint...

//ok - try to address the transder issue first..
//ok - also, add int he nft_mint_many -- add that too..
//we should get more results...


//then, if we don't have 2334
//and if we don't get an update on the owner of 1025, we should go ask in discord...
//need to figure out what is going on...

//one idea, try to skip 1000 items ahead, maybe it is an issue with how many entries can get loaded 
//to the fron tend...


//again weird results, drop all the metadata related stuff, drop ipfs part...
//


//ok... we are still capped at a limited number of results..
//1025 is still an issue...
//there is a problem --> we need internal logic...
//because once the token is found...
//it does not get updated if it is then fouund through via a transfer.. i.e. the mint gets picked up first...



//confirm this is the case... do a run again, this time without mint --> do we get transfers at least?
  //result of testing with transfer only?
  //do we get them picked up?
  //if yes, we need to have some internal logic below...
  //no, we don't get anything... weird...

  //try with buy only --> do we get anything?

  //do we get something with mint only? --> w

  //ok, what is going on then?... --> ok with mint only we get some results again..
  //we also see really high ID's, if we 
  
    //see this guy minted alot...
    /* "id": "034ce6cbe176fb58b347df767df6094ca7daadf9abdef1bff2c1e7bfbb28f1e1",
    "tokens": [
    {
        "id": "3063"
    }
    ]
    }, */


//Ok, so it seems like we have found our issue...
//we are not properly parsing for the transfer events...
//there are two:
//one - when a straight up transfer is called... "nft_transfer"
//and two - "nft_transfer_payout" -- this is what gets called when... somwonw buys an nft on the exchange...


//example buy: https://explorer.near.org/transactions/J7kASGzvoDFmuQ5qiDr4JyJJv7YtgSSikmR5bRBhPF2E
//Called method: 'nft_transfer_payout' in contract: futurenft.near
//EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"old_owner_id":"kaspa.near","new_owner_id":"rkirby.near","token_ids":["1081"]}]}
//the method is different, but the 'event is the same' as a nft_transfer method call
//example of nft transfer method call in contract: futurenft.near:https://explorer.near.org/transactions/npV7FcyfFLobTcJmXoTbTRj9L4rmMM5okduVCnCAjnQ
//EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"old_owner_id":"0hmyxiaoryls.near","new_owner_id":"thisjoys.near","token_ids":["1025"]}]}

//update our mapping to capture these method calls as well...


//does this work, are we getting transfers? -- we really should drop out the mint seciton to make it easy..
//commented out 'mint' selectors...
//are we getting transfers? 
//definitely getting something... ok works...


//we should check to see we are getting both types later on...
//check to see we get both the buy and the transfer contract calls...
//so come back and comment one of them out.. if the above works?
//comment out nft_transfer method --> do we get anything for the near_transfer_payout method?
//-->we should get something... ok we got something
//-->runnign with all now...
//-->do a pagination run to try and pull all the records...
//-->ok, that seemed to work...

//LAST...
//look at ... for afternoon...
//near cli calls to create group/policy for NFTs...
//https://github.com/near-daos/sputnik-dao-contract/tree/feat/enchance-contract-v2-readme/sputnikdao2
//look at testing section...
//https://github.com/r-strawser/subgraph-refinery/tree/main/subgraphs/tenkbay
//debug collection...?



//https://docs.microsoft.com/en-us/sql/relational-databases/json/convert-json-data-to-rows-and-columns-with-openjson-sql-server?view=sql-server-ver15
//trying doing this to parse the data...
//just for fun to see the data in a table...

//also, explore some of the query possibilities --> can we get our data cleaner?
//https://thegraph.com/docs/en/developer/querying-from-your-app/
//querying from your app...
//https://www.youtube.com/watch?v=gjl1dx7iYqg
//https://github.com/dodgeblaster/youtube/tree/master/graphql/apolloclient/back

//also, could there be other issues with this guys pull code we are also missing?
//need to take a close look at it...
//








//critical question --> and hopefully we can verify it through testing...
//does the indexer work from back to front?
//i.e. 













//if yes, we need to have some additional internal logic...
  //we need to have a field/flag that reflects the state of things...

//we also need to ask a general question --> does it pick up the most recent result?
//can we include a time stamp? -- or is there a way to have this handled internally...



//next step once we get query qorking --> how to call the api directly to query results...
//https://medium.com/refinitiv-developer-community/how-to-test-rest-api-with-visual-studio-code-rest-client-extensions-9f2e061d0299
//there has to be some docs on this in the thegraph website/documentation location...
//




//Grant proposal...
//it is possible to use the pulled metadata to categorize the NFTs by rarity
//we can also pull the price
//we can also get the block hash
//from that we can get the block id
//from that we can get the time...
//from there... we can get a time series of all of the activity ...
//e.g. we could some get really cool graphical stuff going --> price behavior of NFTs across different 'classes of rarity'
//this could be huge for e.g. identifying problematic NFTs etc... wash trading/manipulation...
//it could help identify when a lower tranche of rarity is about to pop into value for example
//this has the potential to  totally change the way people look at trading NFTs...


